/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   raycasting.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: lwoiton <lwoiton@student.42prague.com>     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/04/26 11:52:40 by lwoiton           #+#    #+#             */
/*   Updated: 2024/05/16 13:54:56 by lwoiton          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/cub3d.h"
#include <math.h>
#include <float.h>
#include <stdbool.h>

// TODO Clean up the coordinates
//@
// TODO: Deleted unnecessary lines and comments
// TODO: Improve 3D rendering
//			- Implement rendering of sprites
//			- Implement rendering of the floor and ceiling
//			- Implement rendering of the skybox
//			- Implement rendering of the HUD
//			- Implement rendering of the minimap

# define deg_to_rad(angle) (angle * M_PI / 180)
# define rad_to_deg(radient) (radient * 180 / M_PI)

void draw_cross(mlx_image_t *img, int x, int y, int size, int color)
{
	for (int i = -size; i <= size; i++)
	{
		if (x + i >= 0 && x + i < (int)img->width)
		{
			mlx_put_pixel(img, x + i, y, color);
		}
		if (y + i >= 0 && y + i < (int)img->height)
		{
			mlx_put_pixel(img, x, y + i, color);
		}
	}
}

void draw_rotated_cross(mlx_image_t *img, int x, int y, int size, int thickness, int color) {
    for (int i = -size; i <= size; i++) {
        for (int j = -thickness; j <= thickness; j++) {
            // Diagonal 1 (\)
            int xi = x + i + j;
            int yi = y + i + j;
            if (xi >= 0 && (uint32_t)xi < img->width && yi >= 0 && (uint32_t)yi < img->height) {
                mlx_put_pixel(img, xi, yi, color);
            }

            // Diagonal 2 (/)
            xi = x + i - j;
            yi = y - i + j;
            if (xi >= 0 && (uint32_t)xi < img->width && yi >= 0 && (uint32_t)yi < img->height) {
                mlx_put_pixel(img, xi, yi, color);
            }
        }
    }
}

void draw_circle_trig(mlx_image_t *img, int center_x, int center_y, int radius, int thickness, int color) {
    for (int r = radius - thickness; r <= radius + thickness; r++) {
        for (int theta = 0; theta < 360; theta++) {
            int x = center_x + r * cos(theta * M_PI / 180.0);
            int y = center_y + r * sin(theta * M_PI / 180.0);

            if (x >= 0 && (uint32_t)x < img->width && y >= 0 && (uint32_t)y < img->height) {
                mlx_put_pixel(img, x, y, color);
            }
        }
    }
}

int nearest_int(double value)
{
	if (value >= 0)
		return ((int) (value + 0.5));
	else
		return ((int) (value - 0.5));
}

int is_zero(double value)
{
  return (fabs(value) < 1e-10);
}

void draw_line2(mlx_image_t *img, double x1, double y1, double x2, double y2, int color) {
    int dx = (int)(x2 - x1);
    int dy = (int)(y2 - y1);
    int steps = (abs(dx) > abs(dy)) ? abs(dx) : abs(dy); // Choose maximum of dx or dy for steps

    double xinc = dx / (double)steps;
    double yinc = dy / (double)steps;

    double x = x1;
    double y = y1;

    for (int i = 0; i <= steps; i++) { // Iterate up to and including steps
        mlx_put_pixel(img, nearest_int(x), nearest_int(y), color); // Use rounding to nearest integer
        x += xinc;
        y += yinc;
    }
}

int nearest_x_or_y(double value, int max_value) {
	if (fabs(value) < 1e-10) {
		return nearest_int(value);
	} else {
		int result = (int)value;
		if (result < 0) {
			result = 0;
		} else if (result >= max_value) {
			result = max_value - 1;
		}
		return result;
	}
}

int set_direction(double value)
{
  if (value < 0)
    return (-1);
  else
    return (1);
}

t_vec_int set_step(t_vec dir)
{
  t_vec_int step;

  step.x = set_direction(dir.x);
  step.y = set_direction(dir.y);
  return (step);
}

void calculate_initial_offset(t_cub3d *cub3d, t_ray *ray, t_vec delta_dist, t_vec_int map,t_vec *offset)
{
  t_vec p;

  p = cub3d->P->pos;
  if (ray->dir.x < 0)
    offset->x = (p.x - map.x * TILE_SIZE) * delta_dist.x;
  else
    offset->x = ((map.x + 1) * TILE_SIZE - p.x) * delta_dist.x;
  if (ray->dir.y < 0)
    offset->y = (p.y - map.y * TILE_SIZE) * delta_dist.y;
  else
    offset->y = ((map.y + 1) * TILE_SIZE - p.y) * delta_dist.y;
}

static int  is_tile_wall(t_cub3d *cub3d, t_ray *ray, t_vec_int map, int wall_type)
{
  ray->wall = cub3d->minimap->map[map.y][map.x];
  if (ray->wall == 0)
    return (ray->wall);
  if (wall_type == 1)
  {
    if (ray->dir.x > 0)
      ray->side = EAST;
    else
      ray->side = WEST;
  }
  else if (wall_type == 0)
  {
    if (ray->dir.y > 0)
      ray->side = SOUTH;
    else
      ray->side = NORTH;
  }
  return (ray->wall);
}

bool vertical_gridline_hit(t_vec *d)
{
  return ((d->x < d->y && !is_zero(d->x)) || is_zero(d->y));
}

void  dda(t_cub3d *cub3d, t_ray *ray, t_vec delta_dist, t_vec_int map, t_vec *distance)
{
  t_vec_int step;

  step = set_step(ray->dir);
  while (true)
  {
    if (vertical_gridline_hit(distance))
    {
      map.x += step.x;
      if (is_tile_wall(cub3d, ray, map, 1))
        break;
      distance->x += delta_dist.x * TILE_SIZE;
    }
    else
    {
      map.y += step.y;
      if (is_tile_wall(cub3d, ray, map, 0))
        break;
      distance->y += delta_dist.y * TILE_SIZE;
    }
  }
}

double inv_abs(double value)
{
  return (1 / fabs(value));
}

void	raycast(t_cub3d *cub3d, t_ray *ray)
{
  t_vec delta_dist;
  t_vec_int map;
  t_vec distance;

  delta_dist = vec_apply(ray->dir, inv_abs);
  map = vec_int_scal_d(cub3d->P->pos, TILE_SIZE);
  calculate_initial_offset(cub3d, ray, delta_dist, map, &distance);
  dda(cub3d, ray, delta_dist, map, &distance);
  if (vertical_gridline_hit(&distance))
    ray->distance = distance.x;
  else
    ray->distance = distance.y;
  ray->distance *= cos(cub3d->P->dir - ray->angle);
  ray->wall_hit = vec_add(cub3d->P->pos, vec_scal_m(ray->dir, ray->distance));
}

uint32_t get_pixel_color(mlx_texture_t *texture, int x, int y)
{
	uint32_t *pixels = (uint32_t *)texture->pixels;
	return (pixels[y * texture->width + x]);
}

uint32_t interpolate_colors(uint32_t c1, uint32_t c2, double alpha) {
    uint8_t r = (uint8_t)((1 - alpha) * ((c1 >> 16) & 0xFF) + alpha * ((c2 >> 16) & 0xFF));
    uint8_t g = (uint8_t)((1 - alpha) * ((c1 >> 8) & 0xFF) + alpha * ((c2 >> 8) & 0xFF));
    uint8_t b = (uint8_t)((1 - alpha) * (c1 & 0xFF) + alpha * (c2 & 0xFF));
    return (r << 16) | (g << 8) | b;
}

uint32_t texture_sample_bilinear(mlx_texture_t *tex, double u, double v) {
    // Convert fractional texture coordinates to texel indices
    double tx = u * tex->width - 0.5;
    double ty = v * tex->height - 0.5;

    // Determine texel indices surrounding the point
    int x1 = (int)floor(tx);
    int y1 = (int)floor(ty);
    int x2 = (x1 + 1) % tex->width;
    int y2 = (y1 + 1) % tex->height;

    // Calculate fractional parts of u and v
    double fx = tx - floor(tx);
    double fy = ty - floor(ty);

    // Fetch four texels
    uint32_t c11 = tex->pixels[y1 * tex->width + x1];
    uint32_t c21 = tex->pixels[y1 * tex->width + x2];
    uint32_t c12 = tex->pixels[y2 * tex->width + x1];
    uint32_t c22 = tex->pixels[y2 * tex->width + x2];

    // Interpolate between the colors
    uint32_t interp1 = interpolate_colors(c11, c21, fx);
    uint32_t interp2 = interpolate_colors(c12, c22, fx);
    uint32_t finalColor = interpolate_colors(interp1, interp2, fy);

    return finalColor;
}

void draw_view(t_cub3d *cub3d, t_ray *ray)
{
	int min_x = ray->index * (cub3d->width / FOV);
	int max_x = (ray->index + 1) * (cub3d->width / FOV);
	int delta_height = (int) (cub3d->height / ray->distance);
	int start = (cub3d->height - delta_height) / 2;
	int end = start + delta_height;

	int tex_num = ray->side;
	// Calculate exact position on the wall texture
  double wallHitX = ray->wall_hit.x;
  double wallHitY = ray->wall_hit.y;

	// Correct texture coordinates based on wall side
	double wallX = (ray->side == NORTH || ray->side == SOUTH) ? wallHitX : wallHitY;
	wallX -= floor(wallX);
	int texX = (int)(wallX * (double)cub3d->textures[tex_num]->width);
	for (int x = min_x; x < max_x; x++)
	{
		for (int y = 0; y < (int) cub3d->height; y++)
		{
			if (y >= start && y <= end)
			{
			    int texY = ((y - start) * cub3d->textures[tex_num]->height) / delta_height;
			    texY = texY % cub3d->textures[tex_num]->height;  // Handle wrapping
			    //uint32_t color = texture_sample_bilinear(cub3d->textures[tex_num], texX, texY);
			    uint32_t color = get_pixel_color(cub3d->textures[tex_num], texX, texY);
			    mlx_put_pixel(cub3d->img, x, y, color);
			}
			else if (y < start)
				mlx_put_pixel(cub3d->img, x, y, 0x00FFFFFF);
			else
				mlx_put_pixel(cub3d->img, x, y, 0xFF000000);
		}
	}
}

void	fov_cast(void *ptr)
{
	t_cub3d	*cub3d = (t_cub3d *) ptr;
	t_ray	ray;

	ray.index = 0;
	double curr_dir = deg_to_rad(-FOV / 2);
	while (curr_dir < deg_to_rad(FOV / 2))
	{
		ray.angle = cub3d->P->dir + curr_dir;
		ray.dir = angle_to_vec(cub3d->P->dir + curr_dir);
		raycast(cub3d, &ray);
		draw_view(cub3d, &ray);
		curr_dir += 0.0175;
		ray.index++;
	}
}
